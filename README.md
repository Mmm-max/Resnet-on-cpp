# Resnet on cpp project


## RELU


## Conv2D
самое сложное здесь это формулы расчета нужной ячейки
для начала разберемся с тем, что имеем на входе 
```
int col = blockIdx.x * blockDim.x + threadIdx.x;
int row = blockIdx.y * blockDim.y + threadIdx.y;
int out_ch = blockIdx.z;
```

- `col` колонка текущего элемента - берем количество пердыдщих блоков (`bockIdx.x`) умножаем на длинну и прибавляем текущий элемнт в данном блоке (все это по ОХ)
- `row` - аналогично `col`
- `out_ch` - количество каналов, которое мы хотим получить на выходе


Теперь к  сути: нам нужно получить индекс из тензора входных значений и тензора весов, чтобы знать, на что умножать
```cpp
int input_idx = (in_ch * H + current_row) * Width + current_col;
int weight_idx = ((out_ch * С_in + in_ch) * 3 + (i + 1) * 3  + (j + 1));
```
### `input_idx`
- `in_ch * H + current_row` - вычисляем, сколько рядов мы уже обработали (полноценно прошли каналов + пройденные ряды в текущем канале)
- ` * Width` - собсна умножаем ряды на колонки и оказываемся в начале текущего ряда.
- `+ current_col` - получаем текущий элемент
### `weight_idx`
Так как выходной предполагает, что мы дробим входные три канала на более мелкие, то и арифметика происходит в разрезе более меклий каналов
- `out_ch * C_in` полносью пройденные пред блоки
- `+ in_ch` - текущий канал в рамках **выходного** канала
- `* 3` - умножаем на размер нашего блока. Блок у нас 3x3
- `i + 1` - изначально в цикле мы проходимся по элементам от -1 до 1, тут же мы переводим это 0 1 2, чтобы можно было использовать для индексации
- `(i + 1) * 3` - аналогично тому, что ранее - умножаем на 3, тк у нас один ряд в блоке = 3
- `j + 1` - аналогично, получаем иднекс колонки в текущем ядре


